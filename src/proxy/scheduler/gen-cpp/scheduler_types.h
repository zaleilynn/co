/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef scheduler_TYPES_H
#define scheduler_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>





typedef struct _TaskInfo__isset {
  _TaskInfo__isset() : framework_name(false), id(false), cmd(false), arguments(false), candidate_ips(false), transfer_files(false), need_cpu(false), need_memory(false) {}
  bool framework_name;
  bool id;
  bool cmd;
  bool arguments;
  bool candidate_ips;
  bool transfer_files;
  bool need_cpu;
  bool need_memory;
} _TaskInfo__isset;

class TaskInfo {
 public:

  static const char* ascii_fingerprint; // = "C01EC14F56CAE147909C7C9A29219C0B";
  static const uint8_t binary_fingerprint[16]; // = {0xC0,0x1E,0xC1,0x4F,0x56,0xCA,0xE1,0x47,0x90,0x9C,0x7C,0x9A,0x29,0x21,0x9C,0x0B};

  TaskInfo() : framework_name(), id(0), cmd(), arguments(), candidate_ips(), transfer_files(), need_cpu(0), need_memory(0) {
  }

  virtual ~TaskInfo() throw() {}

  std::string framework_name;
  int64_t id;
  std::string cmd;
  std::string arguments;
  std::string candidate_ips;
  std::string transfer_files;
  double need_cpu;
  int32_t need_memory;

  _TaskInfo__isset __isset;

  void __set_framework_name(const std::string& val) {
    framework_name = val;
  }

  void __set_id(const int64_t val) {
    id = val;
  }

  void __set_cmd(const std::string& val) {
    cmd = val;
  }

  void __set_arguments(const std::string& val) {
    arguments = val;
  }

  void __set_candidate_ips(const std::string& val) {
    candidate_ips = val;
  }

  void __set_transfer_files(const std::string& val) {
    transfer_files = val;
  }

  void __set_need_cpu(const double val) {
    need_cpu = val;
  }

  void __set_need_memory(const int32_t val) {
    need_memory = val;
  }

  bool operator == (const TaskInfo & rhs) const
  {
    if (!(framework_name == rhs.framework_name))
      return false;
    if (!(id == rhs.id))
      return false;
    if (!(cmd == rhs.cmd))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    if (!(candidate_ips == rhs.candidate_ips))
      return false;
    if (!(transfer_files == rhs.transfer_files))
      return false;
    if (!(need_cpu == rhs.need_cpu))
      return false;
    if (!(need_memory == rhs.need_memory))
      return false;
    return true;
  }
  bool operator != (const TaskInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TaskInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(TaskInfo &a, TaskInfo &b);

typedef struct _FrameworkInfo__isset {
  _FrameworkInfo__isset() : name(false), quota(false), command(false), arguments(false), cpu(false), memory(false) {}
  bool name;
  bool quota;
  bool command;
  bool arguments;
  bool cpu;
  bool memory;
} _FrameworkInfo__isset;

class FrameworkInfo {
 public:

  static const char* ascii_fingerprint; // = "A2F6FEE8052EF81D7C843808325D27F8";
  static const uint8_t binary_fingerprint[16]; // = {0xA2,0xF6,0xFE,0xE8,0x05,0x2E,0xF8,0x1D,0x7C,0x84,0x38,0x08,0x32,0x5D,0x27,0xF8};

  FrameworkInfo() : name(), quota(0), command(), arguments(), cpu(0), memory(0) {
  }

  virtual ~FrameworkInfo() throw() {}

  std::string name;
  int32_t quota;
  std::string command;
  std::string arguments;
  double cpu;
  int32_t memory;

  _FrameworkInfo__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_quota(const int32_t val) {
    quota = val;
  }

  void __set_command(const std::string& val) {
    command = val;
  }

  void __set_arguments(const std::string& val) {
    arguments = val;
  }

  void __set_cpu(const double val) {
    cpu = val;
  }

  void __set_memory(const int32_t val) {
    memory = val;
  }

  bool operator == (const FrameworkInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(quota == rhs.quota))
      return false;
    if (!(command == rhs.command))
      return false;
    if (!(arguments == rhs.arguments))
      return false;
    if (!(cpu == rhs.cpu))
      return false;
    if (!(memory == rhs.memory))
      return false;
    return true;
  }
  bool operator != (const FrameworkInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FrameworkInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FrameworkInfo &a, FrameworkInfo &b);



#endif
